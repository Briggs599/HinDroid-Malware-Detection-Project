import re
import json
import time
import pandas as pd
import numpy as np
from data_pipeline.unpack import *
from data_pipeline.extract_features import *
import scipy.sparse # should build all matricies with this
import threading

#memory efficient matrix creation
multi_threading = True
#only parse once
# build matricies one app at a time but have a function to merge them into a global app

def create_app_matrix(benign_fp,benign_app,mal_fp,mal_app):
    start = time.time()
    
    app_list = []
    for b in benign_app:
        app_list.append(benign_fp + "/"+b)
    for m in mal_app:
        app_list.append(mal_fp + "/"+m)

    #Multithreading brain builds eight apps at the same time
    if multi_threading == True:
        print("Multithreading Enabled")
        if len(app_list) % 8 == 0:
            print("Sufficient apps present, running " + str(int(len(app_list)/8)) + " group(s) of 8 threads")
            for i in np.arange(0,len(app_list),8):
                print()
                
                t1 = threading.Thread(target=build_individual, args=(app_list[0],)) 
                t2 = threading.Thread(target=build_individual, args=(app_list[1],))
                t3 = threading.Thread(target=build_individual, args=(app_list[2],)) 
                t4 = threading.Thread(target=build_individual, args=(app_list[3],))
                t5 = threading.Thread(target=build_individual, args=(app_list[4],)) 
                t6 = threading.Thread(target=build_individual, args=(app_list[5],))
                t7 = threading.Thread(target=build_individual, args=(app_list[6],)) 
                t8 = threading.Thread(target=build_individual, args=(app_list[7],))
                
                t1.start() 
                t2.start() 
                t3.start() 
                t4.start()
                t5.start() 
                t6.start() 
                t7.start() 
                t8.start()
                
                t1.join() 
                t2.join() 
                t3.join() 
                t4.join()
                t5.join() 
                t6.join() 
                t7.join() 
                t8.join()
                
                app_list = app_list[8:]
                
        else:
            print("Insufficient apps present, running only single threading")
            print()
            for i in app_list:
                build_individual(i)
    else:
        print("Multithreading Disabled, running only single threading")
        print()
        for i in app_list:
                build_individual(i)
                
    print("--- All Apps Parsed in " + str(int(time.time() - start)) + " seconds, Starting Matrix Creation ---")
    print()
    print()
    start = time.time()
    #
    # matrix build here
    #
    print("Matrix creation done in "+ str(int(time.time() - start)) +" seconds")


    
    
def build_individual(path):
    #extracts all relevent data from apps in the form of lists of lists
    start = time.time()
    
    temp = ""
    all_rel_info = [] # list of lists with each inner list being a codeblock of methods
    
    for root, dirs, files in os.walk(path, topdown=False):
            for name in files:
                t = str(os.path.join(root, name))
                if t[-6:] == ".smali":
                    temp = temp + str(open(t, "r").read())
                    
    code_blocks = temp.split(".end method")
    for bloc in code_blocks:
        all_rel_info.append(re.findall('invoke-.+', bloc))
    
    with open("data_extract/" + path.split("/")[-1] +'_extract.txt', 'w') as filehandle:
        for listitem in all_rel_info:
            filehandle.write('%s\n' % listitem)
    print("App " + path.split("/")[-1] + " is parsed in " + str(int(time.time() - start)) +" seconds")
    return
    
    
    
#A
#def app_build_A

#B
#def app_build_B

#P
#def app_build_P

#I
#def app_build_I


#build final matrix for each one
#def assemble_full_matrix()