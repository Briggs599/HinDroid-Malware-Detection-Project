### class contains methods for extracting features from app data
import re
import json

def build_api_dict(directory, app, global_dict):
    """Adds api calls and frequencies for a single app to global api dictionary and returns it
    
    :param directory : str
        Filepath to directory containing app data 
        
    :param app : str
        Name of app
        
    :param global_dict : dict
        Global api dictionary to augment
    """
    with open(directory + "/" + app + "_extract.json", "r") as f:
            codeblocks = json.load(f)

    for codeblock in codeblocks:
        for method in codeblock:
            api_call = method.split("}, ")
            if api_call[-1] not in global_dict:
                global_dict[api_call[-1]] = 1
            else:
                global_dict[api_call[-1]] += 1
    return global_dict


def build_invoke_method_dict(directory, app, global_dict):
    """Adds invoke methods and frequencies for a single app to global invoke method dictionary and returns it
    
    :param directory : str
        Filepath to directory containing app data 
        
    :param app : str
        Name of app
        
    :param global_dict : dict
        Global api dictionary to augment
    """
    with open(directory + "/" + app + "_extract.json", "r") as f:
            codeblocks = json.load(f)

    for codeblock in codeblocks:
        for method in codeblock:
            invoke = re.findall('(?<=\-)(.+?)(?=\{)', method)[0].strip()
            if invoke not in global_dict.keys():
                global_dict[invoke] = 1
            else:
                global_dict[invoke] += 1
    return global_dict


##################################

def build_api_codeblock_dict(directory, app, api_codeblock_dict): #B
    """Creates dictionary for a single app where keys are unique api calls and values are lists of api calls that occur in its same code block 
    This dictionary will be used to construct Matrix B 
    
    :param directory : str
        Filepath to directory containing app data 
        
    :param app : str
        Name of app
    """
    
    with open(directory + "/" + app + "_extract.json", "r") as f:
            codeblocks = json.load(f)

    for codeblock in codeblocks:
        cb_calls = [] #keep list of api calls within codeblock
        
        #BLOCK B
        if len(codeblock) < 2:
            pass
        else:
            for method in codeblock:
                cb_calls.append(method.split("}, ")[-1])

            for call in cb_calls:
                neighbors = list(set([x for x in cb_calls if x != call])) #set returns only unique values
                if call not in api_codeblock_dict.keys():
                    api_codeblock_dict[call] = neighbors
                    
     
    return api_codeblock_dict



def build_api_package_dict(directory, app,package_dict):
    """Creates dictionary for a single app where keys are unique api calls and values are lists of api calls that have the same package name
    This dictionary will be used to construct Matrix P 
    
    :param directory : str
        Filepath to directory containing app data 
        
    :param app : str
        Name of app
    """
    #(key, val) = (api call, package name)
    api_package_dict = {} #(key, val) = (api call, list of api calls with same package name) 
    
    with open(directory + "/" + app + "_extract.json", "r") as f:
            codeblocks = json.load(f)

    for codeblock in codeblocks:
        
        for method in codeblock:
            api_call = method.split("}, ")[-1]
            package = re.findall('^[/a-zA-z]+;{1}', api_call)[0].strip(';')
                
            if api_call not in package_dict.keys():
                package_dict[api_call] = package
        
        inverted_package_dict = {} #(key, val) = (package name, list of api calls with this package name)
        for call, pack in package_dict.items():
            try:
                inverted_package_dict[pack].append(call)
            except:
                inverted_package_dict[pack] = [call]
        
        for api_list in inverted_package_dict.values():
            for api in api_list:
                neighbors = list(set([x for x in api_list if x != api])) #set returns only unique values
                if api not in api_package_dict.keys():
                    api_package_dict[api] = neighbors
     
    return api_package_dict


def build_api_invoke_dict(directory, app, invoke_dict):
    """Creates dictionary for a single app where keys are unique api calls and values are lists of api calls that have the same invoke type
    This dictionary will be used to construct Matrix I 
    
    :param directory : str
        Filepath to directory containing app data 
        
    :param app : str
        Name of app
    """
    invoke_dict = {} #(key, val) = (api call, invoke type)
    api_invoke_dict = {} #(key, val) = (api call, list of api calls with same invoke type) 
    
    with open(directory + "/" + app + "_extract.json", "r") as f:
            codeblocks = json.load(f)

    for codeblock in codeblocks:
        
        for method in codeblock:
            invoke = re.findall('(?<=\-)(.+?)(?=\{)', method.split("}, ")[-1])[0].strip()
                
            if api_call not in invoke_dict.keys():
                invoke_dict[api_call] = invoke
        
        inverted_invoke_dict = {} #(key, val) = (invoke type, list of api calls with this invoke type)
        for call, inv in invoke_dict.items():
            try:
                inverted_invoke_dict[inv].append(call)
            except:
                inverted_invoke_dict[inv] = [call]
        
        for api_list in inverted_invoke_dict.values():
            for api in api_list:
                neighbors = list(set([x for x in api_list if x != api])) #set returns only unique values
                if api not in api_invoke_dict.keys():
                    api_invoke_dict[api] = neighbors
     
    return api_invoke_dict