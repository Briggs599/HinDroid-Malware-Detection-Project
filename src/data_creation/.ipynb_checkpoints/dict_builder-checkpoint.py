import re
import json
import os
import numpy as np
import time
import random

with open("config/model.json", "r") as read_file:
    params = json.load(read_file)
test_split = params["test_split"]

with open("config/dict_build.json", "r") as read_file:
    params = json.load(read_file)
    
direc = params["directory"]
verbose = params["verbose"]

def fast_dict(direc = params["directory"]): #very fast WOOOSH
    """Builds dictionaries which can be converted into matricies A,B,P,I, along with corrisponding test matrices

    :return; four dictionaries corrisponding to matricies A,B,P,I and four test matrices A,B,P,I
    """
    #########################
    #FOR TRAIN PORTION OF SPLIT
    #########################
    B = {}
    P_dict = {}
    I_dict = {}
    A = {}
    list_of_files = []
    for root, dirs, files in os.walk(direc):
        list_of_files.append(files)
    list_of_files = list(set([item for sublist in list_of_files for item in sublist]))
    random.shuffle(list_of_files)
    print(str(len(list_of_files)) + " Total Files for Dictionary Creation")
    print("Train Set")
    for file in list_of_files[:int(len(list_of_files) * (1-test_split))]:
        if file not in A:
                        A[file] = [] 
        with open(direc + file, "r") as f:
            filez = json.load(f)
        #MAT A
        A[file] = list(set([item for sublist in filez for item in sublist]))
        print("Parsing " + str(len(filez)) + " Blocks from " + file.rstrip(".json"))    
        for block in filez:
            for meth in block:
                #build global dict of unique api calls
                if meth not in B:
                    B[meth] = []   
                #only keeps unique apis the cooccur in code block (B)
                B[meth] = list(set(B[meth] + block))    
                if meth not in P_dict:
                    P_dict[meth] = []   
                if meth not in I_dict:
                    I_dict[meth] = []      
    P = {}
    I = {}
    dst = time.time()
    for out_ke,counter in zip(I_dict.keys(),np.arange(len(I_dict.keys()))):
        out_inv = out_ke.split("}, ")[0].split(" ")[0].strip()
        if out_inv not in I:
                    I[out_inv] = [] 
        I[out_inv].append(out_ke)
        out_pack = out_ke.split(";")[0].split(",")[1].strip()
        if out_pack not in P:
                    P[out_pack] = [] 
        P[out_pack].append(out_ke)
        if verbose == True:
            if counter % 100000 == 0:
                print(str(np.round((counter/len(I_dict.keys()))*100,2)) + "% Parsing Done In " + str(time.time() - dst) + "s")
                dst = time.time()
                
    #########################
    #FOR TEST PORTION OF SPLIT
    #########################
    
    print()
    print("Test Set")
    B_test = {}
    P_dict_test = {}
    I_dict_test = {}
    A_test = {}
    for file in list_of_files[int(len(list_of_files) * (1-test_split)):]:
        if file not in A_test:
                        A_test[file] = [] 
        with open(direc + file, "r") as f:
            filez = json.load(f)   
        A_test[file] = list(set([item for sublist in filez for item in sublist]))
        
        print("Parsing " + str(len(filez)) + " Blocks from " + file.rstrip(".json"))    
        for block in filez:
            for meth in block:
                if meth not in B_test:
                    B_test[meth] = []   
                B_test[meth] = list(set(B_test[meth] + block))     
                if meth not in P_dict_test:
                    P_dict_test[meth] = [] 
                if meth not in I_dict_test:
                    I_dict_test[meth] = []         
    P_test = {}
    I_test = {}
    dst = time.time()
    for out_ke,counter in zip(I_dict_test.keys(),np.arange(len(I_dict_test.keys()))):
        out_inv = out_ke.split("}, ")[0].split(" ")[0].strip()
        if out_inv not in I_test:
                    I_test[out_inv] = [] 
        I_test[out_inv].append(out_ke)
        out_pack = out_ke.split(";")[0].split(",")[1].strip()
        if out_pack not in P_test:
                    P_test[out_pack] = [] 
        P_test[out_pack].append(out_ke)
        if verbose == True:
            if counter % 100000 == 0:
                print(str(np.round((counter/len(I_dict.keys()))*100,2)) + "% Parsing Done In " + str(time.time() - dst) + "s")
                dst = time.time()
                
    return B, P, I, A, B_test, P_test, I_test, A_test
                    
                    
                        
                    
                    
            
        