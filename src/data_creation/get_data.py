import re
import json
import time
import pandas as pd
import numpy as np
from src.data_creation.unpack import *
import threading

with open("config/parsing_data.json", "r") as read_file:
    params = json.load(read_file)
multi_threading = params["multithreading"]
verbose = params["verbose"]
out_path = params["out_path"]


def create_app_files(benign_fp,benign_app,mal_fp,mal_app):
    """Parses and saves as JSON all supplied apps both benign and mal. Uses multi threading to speed up this process
    
    :param benign_fp : str
        Filepath to benign apps
    :param benign_app : str
        Name of benign app
    :param mal_fp : str
        Filepath to mal apps
    :param mal_app : str
        Name of mal app
    :return True : boolean
        confirmation of successful excecution
    """
    
    start = time.time()
    
    app_list = []
    for b in benign_app:
        app_list.append(benign_fp + "/"+b)
    for m in mal_app:
        app_list.append(mal_fp + "/"+m)

    #Multithreading brain builds eight apps at the same time
    if multi_threading == True:
        print("Multithreading Enabled")
        if len(app_list) % 8 == 0:
            print("Sufficient apps present, running " + str(int(len(app_list)/8)) + " group(s) of 8 threads")
            for i in np.arange(0,len(app_list),8):
                print()
                
                t1 = threading.Thread(target=get_json, args=(app_list[0],benign_app,)) 
                t2 = threading.Thread(target=get_json, args=(app_list[1],benign_app,))
                t3 = threading.Thread(target=get_json, args=(app_list[2],benign_app,)) 
                t4 = threading.Thread(target=get_json, args=(app_list[3],benign_app,))
                t5 = threading.Thread(target=get_json, args=(app_list[4],benign_app,)) 
                t6 = threading.Thread(target=get_json, args=(app_list[5],benign_app,))
                t7 = threading.Thread(target=get_json, args=(app_list[6],benign_app,)) 
                t8 = threading.Thread(target=get_json, args=(app_list[7],benign_app,))
                
                t1.start() 
                t2.start() 
                t3.start() 
                t4.start()
                t5.start() 
                t6.start() 
                t7.start() 
                t8.start()
                
                t1.join() 
                t2.join() 
                t3.join() 
                t4.join()
                t5.join() 
                t6.join() 
                t7.join() 
                t8.join()
                
                app_list = app_list[8:]
                
        else:
            print("Insufficient apps present, running only single threading")
            
            for i in app_list:
                get_json(i,benign_app)
    else:
        print("Multithreading Disabled, running only single threading")
        
        for i in app_list:
                get_json(i,benign_app)
    return True


def get_json(path,benign_app):
    """Creates json file for app in 'matricies/data_extract' folder that contains a list of lists, 
    where each inner list is a codeblock of methods 
    
    :param path : str
        Filepath to app directory
    """
    start = time.time()
    
    if path.split("/")[-1] in benign_app:
        typer = "_B_"
    else:
        typer = "_M_"
    
    temp = ""
    all_rel_info = [] # list of lists with each inner list being a codeblock of methods
    
    for root, dirs, files in os.walk(path, topdown=False):
            for name in files:
                t = str(os.path.join(root, name))
                if t[-6:] == ".smali":
                    temp = temp + str(open(t, "r").read())
                    
    code_blocks = temp.split(".end method")
    for bloc in code_blocks:
        all_rel_info.append(re.findall('invoke-.+', bloc))
    
    with open(out_path + path.split("/")[-1] +typer+'extract.json', 'w') as f:
        json.dump(all_rel_info, f)
        
    if verbose == True:   
        print("App " + path.split("/")[-1] + " is parsed in " + str(int(time.time() - start)) +" seconds")
    return
    