import re
import json
import os
import numpy as np
import time
import random

with open("config/model.json", "r") as read_file:
    params = json.load(read_file)
test_split = params["test_split"]

with open("config/dict_build.json", "r") as read_file:
    params = json.load(read_file)
    
direc = params["directory"]
verbose = params["verbose"]
truncate = params["truncate"]
lower_bound_api_count = params["lower_bound_api_count"]


def fast_dict(direc = params["directory"]):
    """Builds dictionaries which can be converted into matrices A,B,P,I, along with corrisponding test matrices

    :return; four dictionaries corresponding to matrices A,B,P,I and a test matrix A_test
    """
    #########################
    #FOR TRAIN PORTION OF SPLIT
    #########################
    B = {}
    P_dict = {}
    I_dict = {}
    A = {}
    count = {}
#     list_of_files = ['com.aqreadd.lw.newyearscountdown.free_B_extract.json', 'com.crowdstar.covetHome_B_extract.json']
    list_of_files = []
    for root, dirs, files in os.walk('HinDroid_malware_detection/src/matrices/data_extract'):
        list_of_files.append(files)
        print(list_of_files)
    #list_of_files = list(set([item for sublist in list_of_files for item in sublist]))
    random.shuffle(list_of_files)
    print(str(len(list_of_files)) + " Total Files for Dictionary Creation")
    print()
    print("Train Set")
    for file in list_of_files[:int(len(list_of_files) * (1-test_split))]:
        if file not in A:
                        A[file] = [] 
        with open(direc + file, "r") as f:
            print(f)
            filez = json.load(f)
        #MAT A
        A[file] = list(set([item for sublist in filez for item in sublist]))
        print("Parsing " + str(len(filez)) + " Blocks from " + file.rstrip(".json"))    
        for block in filez:
            for meth in block:
                #build global dict of unique api calls
                if meth not in B:
                    B[meth] = []   
                #only keeps unique apis the cooccur in code block (B)
                B[meth] = list(set(B[meth] + block))    
                if meth not in P_dict:
                    P_dict[meth] = []   
                if meth not in I_dict:
                    I_dict[meth] = []
                if meth not in count:
                    count[meth] = 0
                count[meth] = count[meth] + 1
    P = {}
    I = {}
    dst = time.time()
    for out_ke,counter in zip(I_dict.keys(),np.arange(len(I_dict.keys()))):
        out_inv = out_ke.split("}, ")[0].split(" ")[0].strip()
        if out_inv not in I:
                    I[out_inv] = [] 
        I[out_inv].append(out_ke)
        out_pack = out_ke.split(";")[0].split(",")[1].strip()
        if out_pack not in P:
                    P[out_pack] = [] 
        P[out_pack].append(out_ke)
        if verbose == True:
            if counter % 100000 == 0:
                print(str(np.round((counter/len(I_dict.keys()))*100,2)) + "% Parsing Done In " + str(time.time() - dst) + "s")
                dst = time.time()
                
    #########################
    #FOR TEST PORTION OF SPLIT
    #########################
    
    print()
    print("Test Set")
    A_test = {}
    for file in list_of_files[int(len(list_of_files) * (1-test_split)):]:
        if file not in A_test:
                        A_test[file] = [] 
        with open(direc + file, "r") as f:
            filez = json.load(f)   
        A_test[file] = list(set([item for sublist in filez for item in sublist]))
        
        print("Parsing " + str(len(filez)) + " Blocks from " + file.rstrip(".json"))    
        for block in filez:
            for meth in block:
                if meth not in count:
                    count[meth] = 0
                count[meth] = count[meth] + 1

        if verbose == True:
            if counter % 100000 == 0:
                print(str(np.round((counter/len(I_dict.keys()))*100,2)) + "% Parsing Done In " + str(time.time() - dst) + "s")
                dst = time.time()
                
    if truncate == True:
        print()
        print("Truncation is set to True, API calls only occuring less than lower_bound_api_count will be removed from the model.")
        print("Number of API calls Before Truncation: " + str(len(B.keys())))
        for i in [B, P, I, A, A_test]:
            #remove files where APIs occur less than lower_bound_api_count across whole data set
            #doesn't work rn
            # remove both keys and values from dict
            
            d = dict((k, v) for k, v in count.items() if v <= lower_bound_api_count)
            for k in d.keys():
                try:
                    del i[k]
                except:continue
        print("Number of API calls After Truncation:  " + str(len(B.keys())))
        print()
    
    
    return B, P, I, A,A_test
                    
                    
                        
                    
                    
            
        