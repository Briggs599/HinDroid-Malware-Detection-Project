import numpy as np
from sklearn import svm
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.datasets import make_classification
from sklearn.metrics import confusion_matrix
import threading
import json
from sklearn.utils.testing import ignore_warnings
from sklearn.exceptions import ConvergenceWarning

with open("config/model.json", "r") as read_file:
    params = json.load(read_file)
multi_threading = params["multithreading"]
test_split = params["test_split"]

def svm_modeler(A,B,P,I, Arows,A_t, Arows_t):
    """Manages Training and evaluating the SVM models with or without multithreading
    
    :param A : numpy matrix
        A matrix
    :param B : numpy matrix
        B matrix
    :param P : numpy matrix
        P matrix
    :param I : numpy matrix
        I matrix
    :param Arows : List
        Names of Apps selected for the training stage
    :param A_t : numpy matrix
        A test matrix
    :param Arows_t : List
        Names of Apps selected for the testing stage
    
    """
    print()
    print("--- Starting Testing ---")
    y = [0 if i.split("_")[-2] == "B" else 1 for i in Arows]
    y_t = [0 if i.split("_")[-2] == "B" else 1 for i in Arows_t]
    print("Total number of apps: " + str(len(y)+len(y_t)))
    print("Split " + str(int(100 - test_split*100)) + "-"+str(int(test_split*100)))
    print("Train set size: " + str(len(y)))
    print("Test set size:  " + str(len(y_t)))
    if multi_threading == True:
        print("Multithreading Enabled")
        print()
        t1 = threading.Thread(target=train_run, args=(A.dot(A.transpose()),y,"AA^T         ",A_t.dot(A.transpose()),y_t))
        t2 = threading.Thread(target=train_run, args=(A.dot(B).dot(A.transpose()),y,"ABA^T        ",A_t.dot(B).dot(A.transpose()),y_t))
        t3 = threading.Thread(target=train_run, args=(A.dot(P).dot(A.transpose()),y,"APA^T        ",A_t.dot(P).dot(A.transpose()),y_t))
        t4 = threading.Thread(target=train_run, args=(A.dot(I).dot(A.transpose()),y,"AIA^T        ",A_t.dot(I).dot(A.transpose()),y_t))
        t5 = threading.Thread(target=train_run, args=(A.dot(B).dot(P).dot(B.transpose()).dot(A.transpose()),y,"ABPB^TA^T    ",A_t.dot(B).dot(P).dot(B.transpose()).dot(A.transpose()),y_t))
        t6 = threading.Thread(target=train_run, args=(A.dot(P).dot(B).dot(P.transpose()).dot(A.transpose()),y,"APBP^TA^T    ",A_t.dot(P).dot(B).dot(P.transpose()).dot(A.transpose()),y_t))
        t7 = threading.Thread(target=train_run, args=(A.dot(B).dot(I).dot(B.transpose()).dot(A.transpose()),y,"ABIB^TA^T    ",A_t.dot(B).dot(I).dot(B.transpose()).dot(A.transpose()),y_t))
        t8 = threading.Thread(target=train_run, args=(A.dot(I).dot(B).dot(I.transpose()).dot(A.transpose()),y,"AIBI^TA^T    ",A_t.dot(I).dot(B).dot(I.transpose()).dot(A.transpose()),y_t))
        t1.start() 
        t2.start() 
        t3.start() 
        t4.start()
        t5.start() 
        t6.start() 
        t7.start() 
        t8.start()
        t1.join() 
        t2.join() 
        t3.join() 
        t4.join()
        t5.join() 
        t6.join() 
        t7.join() 
        t8.join()
        t1 = threading.Thread(target=train_run, args=(A.dot(P).dot(I).dot(P.transpose()).dot(A.transpose()),y,"APIP^TA^T    ",A_t.dot(P).dot(I).dot(P.transpose()).dot(A.transpose()),y_t))
        t2 = threading.Thread(target=train_run, args=(A.dot(I).dot(P).dot(I.transpose()).dot(A.transpose()),y,"AIPI^TA^T    ",A_t.dot(I).dot(P).dot(I.transpose()).dot(A.transpose()),y_t))
        t3 = threading.Thread(target=train_run, args=(A.dot(B).dot(P).dot(I).dot(P.transpose()).dot(B.transpose()).dot(A.transpose()),y,"ABPIP^TB^TA^T",A_t.dot(B).dot(P).dot(I).dot(P.transpose()).dot(B.transpose()).dot(A.transpose()),y_t))
        t4 = threading.Thread(target=train_run, args=(A.dot(P).dot(B).dot(I).dot(B.transpose()).dot(P.transpose()).dot(A.transpose()),y,"APBIB^TP^TA^T",A_t.dot(P).dot(B).dot(I).dot(B.transpose()).dot(P.transpose()).dot(A.transpose()),y_t))
        t5 = threading.Thread(target=train_run, args=(A.dot(B).dot(I).dot(P).dot(I.transpose()).dot(B.transpose()).dot(A.transpose()),y,"ABIPI^TB^TA^T",A_t.dot(B).dot(I).dot(P).dot(I.transpose()).dot(B.transpose()).dot(A.transpose()),y_t))
        t6 = threading.Thread(target=train_run, args=(A.dot(I).dot(B).dot(P).dot(B.transpose()).dot(I.transpose()).dot(A.transpose()),y,"AIBPB^TI^TA^T",A_t.dot(I).dot(B).dot(P).dot(B.transpose()).dot(I.transpose()).dot(A.transpose()),y_t))
        t7 = threading.Thread(target=train_run, args=(A.dot(I).dot(P).dot(B).dot(P.transpose()).dot(I.transpose()).dot(A.transpose()),y,"AIPBP^TI^TA^T",A_t.dot(I).dot(P).dot(B).dot(P.transpose()).dot(I.transpose()).dot(A.transpose()),y_t))
        t8 = threading.Thread(target=train_run, args=(A.dot(P).dot(I).dot(B).dot(I.transpose()).dot(P.transpose()).dot(A.transpose()),y,"APIBI^TP^TA^T",A_t.dot(P).dot(I).dot(B).dot(I.transpose()).dot(P.transpose()).dot(A.transpose()),y_t))
        t1.start() 
        t2.start() 
        t3.start() 
        t4.start()
        t5.start() 
        t6.start() 
        t7.start() 
        t8.start()
        t1.join() 
        t2.join() 
        t3.join() 
        t4.join()
        t5.join() 
        t6.join() 
        t7.join() 
        t8.join()
    else:
        print("Multithreading Disabled")
        print()
        train_run(A.dot(A.transpose()),y,"AA^T         ",A_t.dot(B).dot(A.transpose()),y_t)
        train_run(A.dot(B).dot(A.transpose()),y,"ABA^T        ",A_t.dot(P).dot(A.transpose()),y_t)
        train_run(A.dot(P).dot(A.transpose()),y,"APA^T        ",A_t.dot(P).dot(A.transpose()),y_t)
        train_run(A.dot(I).dot(A.transpose()),y,"AIA^T        ",A_t.dot(I).dot(A.transpose()),y_t)
        train_run(A.dot(B).dot(P).dot(B.transpose()).dot(A.transpose()),y,"ABPB^TA^T    ",A_t.dot(B).dot(P).dot(B.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(P).dot(B).dot(P.transpose()).dot(A.transpose()),y,"APBP^TA^T    ",A_t.dot(P).dot(B).dot(P.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(B).dot(I).dot(B.transpose()).dot(A.transpose()),y,"ABIB^TA^T    ",A_t.dot(B).dot(I).dot(B.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(I).dot(B).dot(I.transpose()).dot(A.transpose()),y,"AIBI^TA^T    ",A_t.dot(I).dot(B).dot(I.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(P).dot(I).dot(P.transpose()).dot(A.transpose()),y,"APIP^TA^T    ",A_t.dot(P).dot(I).dot(P.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(I).dot(P).dot(I.transpose()).dot(A.transpose()),y,"AIPI^TA^T    ",A_t.dot(I).dot(P).dot(I.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(B).dot(P).dot(I).dot(P.transpose()).dot(B.transpose()).dot(A.transpose()),y,"ABPIP^TB^TA^T",A_t.dot(B).dot(P).dot(I).dot(P.transpose()).dot(B.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(P).dot(B).dot(I).dot(B.transpose()).dot(P.transpose()).dot(A.transpose()),y,"APBIB^TP^TA^T",A_t.dot(P).dot(B).dot(I).dot(B.transpose()).dot(P.transpose()).dot(A.transpose()),y_t) 
        train_run(A.dot(B).dot(I).dot(P).dot(I.transpose()).dot(B.transpose()).dot(A.transpose()),y,"ABIPI^TB^TA^T",A_t.dot(B).dot(I).dot(P).dot(I.transpose()).dot(B.transpose()).dot(A.transpose()),y_t) 
        train_run(A.dot(I).dot(B).dot(P).dot(B.transpose()).dot(I.transpose()).dot(A.transpose()),y,"AIBPB^TI^TA^T",A_t.dot(I).dot(B).dot(P).dot(B.transpose()).dot(I.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(I).dot(P).dot(B).dot(P.transpose()).dot(I.transpose()).dot(A.transpose()),y,"AIPBP^TI^TA^T",A_t.dot(I).dot(P).dot(B).dot(P.transpose()).dot(I.transpose()).dot(A.transpose()),y_t)
        train_run(A.dot(P).dot(I).dot(B).dot(I.transpose()).dot(P.transpose()).dot(A.transpose()),y,"APIBI^TP^TA^T",A_t.dot(P).dot(I).dot(B).dot(I.transpose()).dot(P.transpose()).dot(A.transpose()),y_t)
        
@ignore_warnings(category=ConvergenceWarning) #Convergency warnings can occur on test data   
def train_run(A,y,structure,A_t,y_t):
    """Trains and evaluates the SVM model
    
    :param A : numpy matrix
        Transformed Kernal for training
    :param y : list
        Target values
    :param structure : string
        The Kernal Structure
    :param A_t : numpy matrix
        Transformed Test Kernal
    :param y_t : list
        Target test values
    
    """
    clf = svm.SVC(kernel = 'precomputed')
    A = A.todense()
    A_t = A_t.todense()
    clf.fit(A, y)
    res = clf.predict(A_t)
    tn, fp, fn, tp = confusion_matrix(y_t, res, labels = [0,1]).ravel()
    print(structure,end = ": ")
    print("TN: " +str(tn), end = ", ")
    print("FP: " +str(fp), end = ", ")
    print("FN: " +str(fn), end = ", ")
    print("TP: " +str(tp), end = ", ")
    if (tp + 0.5*(fp+fn)) == 0:
        F1 = 0
    else:
        F1 = tp /(tp + 0.5*(fp+fn)) 
    acc = (tp+tn) / (tp+tn+fp+fn)
    print("ACC: " + str(acc*100) + "%")
    if tp+fp == 0:
        prec = 0
    else:
        prec = tp/(tp+fp)
    
    if tp+fn == 0:
        reca = 0
    else:
        reca = tp/(tp+fn)
    f = open("results/"+structure, "a")
    f.write("ACC:"+ str(acc) +", F1:"+str(F1) +", Precision:"+str(prec) +", Recall:" + str(reca) +", TN:"+str(tn) +", FP:"+str(fp) +", FN:" +str(fn) +", TP:" +str(tp))
    f.close()
    return True
   